#!/usr/bin/env python3
import os
from openai import OpenAI
from pydantic import BaseModel
import subprocess
import argparse
import json
import sys

def get_staged_files():
    result = subprocess.run(["git", "diff", "--cached", "--name-only"], capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception("Error executing git diff --cached.")
    files = result.stdout.strip().split('\n')
    return [f for f in files if f]  # Filter out empty lines

def get_diff():
    result = subprocess.run(["git", "diff", "--cached"], capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception("Error executing git diff --cached.")
    return result.stdout

def load_file_content(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        print(f"Unable to read file {file_path}: {e}", file=sys.stderr)
        return ""

def load_modified_files_contents(files):
    contents = {}
    for file in files:
        contents[file] = load_file_content(file)
    return contents

def load_readme():
    readme_files = ['README.md', 'README.rst', 'README']
    for readme in readme_files:
        if os.path.exists(readme):
            return load_file_content(readme)
    return ""

def generate_commit_message(diff, files_contents, readme, user_description=None):

    commit_message = ""

    prompt = "Generate a clear and concise Git commit message based on the following information.\n\n"

    if user_description:
        prompt += f"Description provided by the user: {user_description}\n\n"

    prompt += "Diff of staged changes:\n"
    prompt += f"{diff}\n\n"

    prompt += "Content of modified files:\n"
    for file, content in files_contents.items():
        prompt += f"--- {file} ---\n{content}\n\n"

    if readme:
        prompt += f"--- README.md ---\n{readme}\n\n"

    prompt += "Please respond only with a JSON object containing the 'commit_message' field."

    # Call to OpenAI API
    try:

        # OpenAI API Configuration
        api_key = os.getenv("OPENAI_API_KEY")

        if not api_key:
            print("Please set the OPENAI_API_KEY environment variable.", file=sys.stderr)
            sys.exit(1)

        openai = OpenAI(
            api_key=api_key,
        )

        # Structured Result
        class CommitExtraction(BaseModel):
            commit_message: str

        response = openai.beta.chat.completions.parse(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": "You are a helpful assistant that helps generate clear and concise Git commit messages."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            response_format=CommitExtraction,
            max_tokens=300,
        )

        # CHOICE
        if not response.choices or len(response.choices) == 0:
            raise Exception("No choices returned from the LLM call.")
        choice = response.choices[0]

        # MESSAGE
        if not choice.message:
            raise Exception("No message content returned from the LLM call.")
        message = choice.message

        commit_json = json.loads(message.content)
        commit_message = commit_json.get('commit_message', '').strip()

    except Exception as e:
        raise Exception(f"Error calling OpenAI API: {e}")
    
    return commit_message


def commit_changes(commit_message):
    # Perform the commit
    result = subprocess.run(["git", "commit", "-m", commit_message], capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Error during commit: {result.stderr}")

def main():

    parser = argparse.ArgumentParser(
        description="Automatic Git commit message generation assistant.",
        usage="git llmcommit -d 'Optional description of changes'"
    )
    parser.add_argument('-d', '--description', type=str, help='Optional description of changes to provide context.')
    args = parser.parse_args()

    try:
        # Step 1: Retrieve staged files
        staged_files = get_staged_files()
        if not staged_files:
            print("No files staged for commit.", file=sys.stderr)
            sys.exit(1)

        # Step 2: Retrieve the diff
        diff = get_diff()

        # Step 3: Load file contents
        files_contents = load_modified_files_contents(staged_files)

        # Load README if available
        readme = load_readme()

        # Step 4: Generate the commit message
        commit_message = generate_commit_message(diff, files_contents, readme, args.description)
        if not commit_message:
            print("Unable to generate a commit message.", file=sys.stderr)
            sys.exit(1)

        print(f"Generated commit message: {commit_message}")

        # Step 5: Perform the commit
        commit_changes(commit_message)
        print("Commit successful.")

    except Exception as e:
        print(f"An error occurred: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
